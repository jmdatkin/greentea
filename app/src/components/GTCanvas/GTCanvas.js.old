import React from 'react';
import { fabric } from 'fabric';

import { utop, ptou } from '../../util/util';
import settings from '../../settings';

import Core from './GTCanvas.core';

import './GTCanvas.scss';

function GTCanvas(props) {

    const MainCanvasRef = React.createRef();
    const GridCanvasRef = React.createRef();

    const [coords, setCoords] = React.useState({
        x: 0,
        y: 0,
        z: 1
    });

    let MainCanvas, GridCanvas;

    React.useEffect(() => {
        console.log('effect');
        MainCanvas = new fabric.Canvas(MainCanvasRef.current);
        GridCanvas = GridCanvasRef.current;

        Core.BindMainCanvas(MainCanvas);
        Core.BindGridCanvas(GridCanvas);

        Core.Init();

        MainCanvas.on('mouse:down', (opt) => {
            console.log('hey');
        });

        MainCanvas.on('mouse:wheel', function (opt) {
            let delta = Math.max(-1, Math.min(opt.e.deltaY, 1));    //Cap delta for x-browser consistency

            let { x, y, z } = coords;
            let [cx, cy] = [ptou(opt.e.offsetX), ptou(opt.e.offsetY)];      //Mouse cursor position

            //Model to rendered position
            cx = cx * z + x;
            cy = cy * z + y;

            let dz = delta * z / 20;                                //Change in z

            let z2 = Math.max(settings.minZoom, Math.min(z + dz, settings.maxZoom));

            /*  https://github.com/cytoscape/cytoscape.js/blob/unstable/src/core/viewport.js  */
            let tx = -z2 / z * (cx - x) + cx;
            let ty = -z2 / z * (cy - y) + cy;

            console.log(tx);

            props.PubSub.emit("view-move", {
                x: tx,
                y: ty,
                z: z2
            });

        });


        let testSquare = new fabric.Rect({
            left: 0,
            top: 0,
            width: 100,
            height: 100,
            fill: 'green',
            stroke: 'black',
            strokeWidth: 5
        });

        MainCanvas.add(testSquare);

            Core.drawAdaptiveGrid(coords,GridCanvas.getContext('2d'));
        props.PubSub.subscribe('view-move', (data) => {
            console.log('viewmove');
            setCoords(data);
            let scaleFactor = 1 / data.z;
            MainCanvas.viewportTransform[0] = scaleFactor;
            MainCanvas.viewportTransform[3] = scaleFactor;
            MainCanvas.viewportTransform[4] = utop(-data.x) / data.z;
            MainCanvas.viewportTransform[5] = utop(-data.y) / data.z;
            testSquare.setCoords();
            Core.drawAdaptiveGrid(coords,GridCanvas.getContext('2d'));
            MainCanvas.renderAll();
        });

        testSquare.setCoords();

        // GridCanvas.getContext('2d').fillRect(0,0,100,100);
    });





    return (
        <div className="GTCanvas">
            <div className="GTCanvas-inner">
                <canvas ref={GridCanvasRef} className="GTCanvas-canvas" id="GTCanvas_grid_canv"></canvas>
                <canvas ref={MainCanvasRef} className="GTCanvas-canvas" id="GTCanvas_main_canv"></canvas>
            </div>
        </div>
    )
}

export default GTCanvas;